/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package com.lindsaylevine.magiccardbuyer

import com.lindsaylevine.magiccardbuyer.optimizer.BuyOptimizer
import com.lindsaylevine.magiccardbuyer.optimizer.PurchaseOption
import com.lindsaylevine.magiccardbuyer.optimizer.VendorProblem
import com.lindsaylevine.magiccardbuyer.tcgplayer.TcgPlayerApi
import java.io.File

class MagicCardBuyer {
    companion object {
        // In cents.
        const val MAX_PRICE = 150
        const val MINIMUM_PURCHASE_PER_VENDOR = 100
        const val COST_PER_VENDOR = 500
    }

    private val tcgPlayerApi = TcgPlayerApi()

    private fun toPurchase(): List<Pair<Card, Int>> {
        val missing = listOf(
                Card("Battlefield Raptor", "Kaldheim") to 2,
                Card("Brinebarrow Intruder", "Kaldheim") to 2,
                Card("Guardian Gladewalker", "Kaldheim") to 1,
                Card("Invoke the Divine", "Kaldheim") to 4,
                Card("Jaspera Sentinel", "Kaldheim") to 2,
                Card("Raise the Draugr", "Kaldheim") to 3,
                Card("Ascent of the Worthy", "Kaldheim") to 1,
                Card("Fearless Liberator", "Kaldheim") to 2,
                Card("Frost Augur", "Kaldheim") to 1,
                Card("Icebind Pillar", "Kaldheim") to 1,
                Card("Shepherd of the Cosmos", "Kaldheim") to 2,
                Card("Tergrid's Shadow", "Kaldheim") to 2,
                Card("The Three Seasons", "Kaldheim") to 1,
                Card("Ascendant Spirit", "Kaldheim") to 1,
                Card("Draugr Necromancer", "Kaldheim") to 1,
                Card("Glorious Protector", "Kaldheim") to 1,
                Card("Shimmerdrift Vale", "Kaldheim") to 1,
                Card("Woodland Chasm", "Kaldheim") to 1,
        )

        return missing + DraftSet("Strixhaven: School of Mages").cards()
    }

    fun execute() {
        val toPurchase = toPurchase()

        println("Finding purchase options...")
        val allCardPurchaseOptions: List<CardPurchaseOptions> =
                toPurchase.map { (card, quantitySought) -> cardPurchaseOptions(card, quantitySought) }

        println("Eliminating too-expensive...")
        val (tooExpensive, purchasable) = allCardPurchaseOptions
                .partition { cardOptions -> cardOptions.options.isEmpty() || cardOptions.options.minOf { it.price } > MAX_PRICE }
        File("tooExpensive").printWriter().use { out ->
            tooExpensive.forEach { out.println("${it.quantitySought} ${it.card.name}") }
        }

        println("Optimizing...")
        val problem = vendorProblem(purchasable)
        val solution = BuyOptimizer().solve(problem)

        println("Purchasing...")
        solution.purchasesToMake.forEach {
            println("Purchasing ${it.quantity} ${it.option.good.name}")
            it.option.purchase(it.quantity)
        }
    }

    private fun cardPurchaseOptions(card: Card, quantitySought: Int): CardPurchaseOptions {
        println("Finding purchase options for ${card.name} from ${card.set}...")
        val options = tcgPlayerApi.purchaseOptions(card)
        if (options.isEmpty()) println("  No options available for ${card.name}!")
        return CardPurchaseOptions(
                card,
                quantitySought,
                tcgPlayerApi.purchaseOptions(card)
        )
    }

    private fun vendorProblem(cardPurchaseOptions: List<CardPurchaseOptions>): VendorProblem<Card> {
        val sought = cardPurchaseOptions.associate { it.card to it.quantitySought }
        val allPurchaseOptions = cardPurchaseOptions.flatMap { it.options }
                .distinctBy { it.key }

        return VendorProblem(
                goodQuantitiesSought = sought,
                purchaseOptions = allPurchaseOptions,
                minimumRequiredPurchase = MINIMUM_PURCHASE_PER_VENDOR,
                costPerVendor = COST_PER_VENDOR
        )
    }

    data class CardPurchaseOptions(
            val card: Card,
            val quantitySought: Int,
            val options: List<PurchaseOption<Card>>
    )

}

fun main() {
    MagicCardBuyer().execute()
}