/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package com.lindsaylevine.magiccardbuyer

import com.lindsaylevine.magiccardbuyer.optimizer.BuyOptimizer
import com.lindsaylevine.magiccardbuyer.optimizer.GreedyOptimizer
import com.lindsaylevine.magiccardbuyer.optimizer.PurchaseOption
import com.lindsaylevine.magiccardbuyer.optimizer.VendorProblem
import com.lindsaylevine.magiccardbuyer.tcgplayer.TcgPlayerApi
import java.io.File

class MagicCardBuyer {
    companion object {
        // In cents.
        const val MAX_PRICE = 150
        const val MINIMUM_PURCHASE_PER_VENDOR = 0
        const val COST_PER_VENDOR = 500
    }

    private val tcgPlayerApi = TcgPlayerApi()

    private fun toPurchase(): List<Pair<Card, Int>> {
        val missing = listOf(
            Card("Baleful Mastery", "Strixhaven: School of Mages") to 1,
            Card("Strategic Planning", "Strixhaven: Mystical Archives") to 3,
            Card("Aether Helix", "Strixhaven: School of Mages") to 2,
            Card("Arcane Subtraction", "Strixhaven: School of Mages") to 5,
            Card("Ardent Dustspeaker", "Strixhaven: School of Mages") to 2,
            Card("Blood Age General", "Strixhaven: School of Mages") to 1,
            Card("Defend the Campus", "Strixhaven: School of Mages") to 3,
            Card("Detention Vortex", "Strixhaven: School of Mages") to 2,
            Card("Elemental Masterpiece", "Strixhaven: School of Mages") to 5,
            Card("Exhilarating Elocution", "Strixhaven: School of Mages") to 5,
            Card("Flunk", "Strixhaven: School of Mages") to 2,
            Card("Heated Debate", "Strixhaven: School of Mages") to 5,
            Card("Humiliate", "Strixhaven: School of Mages") to 2,
            Card("Inkling Summoning", "Strixhaven: School of Mages") to 5,
            Card("Lash of Malice", "Strixhaven: School of Mages") to 5,
            Card("Mage Hunters' Onslaught", "Strixhaven: School of Mages") to 5,
            Card("Oggyar Battle-Seer", "Strixhaven: School of Mages") to 5,
            Card("Pilgrim of the Ages", "Strixhaven: School of Mages") to 5,
            Card("Pillardrop Warden", "Strixhaven: School of Mages") to 2,
            Card("Prismari Pledgemage", "Strixhaven: School of Mages") to 5,
            Card("Promising Duskmage", "Strixhaven: School of Mages") to 5,
            Card("Reckless Amplimancer", "Strixhaven: School of Mages") to 5,
            Card("Reflective Golem", "Strixhaven: School of Mages") to 2,
            Card("Shadewing Laureate", "Strixhaven: School of Mages") to 2,
            Card("Snow Day", "Strixhaven: School of Mages") to 2,
            Card("Specter of the Fens", "Strixhaven: School of Mages") to 5,
            Card("Test of Talents", "Strixhaven: School of Mages") to 1,
            Card("Wormhole Serpent", "Strixhaven: School of Mages") to 2,
        )

        return missing + DraftSet("Adventures in the Forgotten Realms").cards()
    }

    fun execute(directOnly: Boolean = false) {
        val toPurchase = toPurchase()

        println("Finding purchase options...")
        val allCardPurchaseOptions: List<CardPurchaseOptions> =
                toPurchase.map { (card, quantitySought) -> cardPurchaseOptions(card, quantitySought, directOnly) }

        println("Eliminating too-expensive...")
        val (tooExpensive, purchasable) = allCardPurchaseOptions
                .partition { cardOptions -> cardOptions.options.isEmpty() || cardOptions.options.minOf { it.price } > MAX_PRICE }
        File("tooExpensive").printWriter().use { out ->
            tooExpensive.forEach { out.println("${it.quantitySought} ${it.card.name}") }
        }

        println("Optimizing...")
        val problem = vendorProblem(purchasable)
        val optimizer = if (directOnly) GreedyOptimizer() else BuyOptimizer()
        val solution =optimizer.solve(problem)

        println("Purchasing...")
        solution.purchasesToMake.forEach {
            println("Purchasing ${it.quantity} ${it.option.good.name} from ${it.option.vendorName}")
            it.option.purchase(it.quantity)
        }
    }

    private fun cardPurchaseOptions(card: Card, quantitySought: Int, directOnly: Boolean): CardPurchaseOptions {
        println("Finding purchase options for ${card.name} from ${card.set}...")
        val options = tcgPlayerApi.purchaseOptions(card, directOnly)
        if (options.isEmpty()) println("  No options available for ${card.name}!")
        return CardPurchaseOptions(
                card,
                quantitySought,
                options
        )
    }

    private fun vendorProblem(cardPurchaseOptions: List<CardPurchaseOptions>): VendorProblem<Card> {
        val sought = cardPurchaseOptions.associate { it.card to it.quantitySought }
        val allPurchaseOptions = cardPurchaseOptions.flatMap { it.options }
                .distinctBy { it.key }

        return VendorProblem(
                goodQuantitiesSought = sought,
                purchaseOptions = allPurchaseOptions,
                minimumRequiredPurchase = MINIMUM_PURCHASE_PER_VENDOR,
                costPerVendor = COST_PER_VENDOR
        )
    }

    data class CardPurchaseOptions(
            val card: Card,
            val quantitySought: Int,
            val options: List<PurchaseOption<Card>>
    )

}

fun main() {
    MagicCardBuyer().execute()
}